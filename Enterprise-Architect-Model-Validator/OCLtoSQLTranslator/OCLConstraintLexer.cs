//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: null
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR null Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g 2023-05-25 17:11:32

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace OCLtoSQL
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "null")]
[System.CLSCompliant(false)]
public partial class OCLConstraintLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int ATSIGN=4;
	public const int BAR=5;
	public const int COLON=6;
	public const int COMMA=7;
	public const int DCOLON=8;
	public const int DIVIDE=9;
	public const int DOT=10;
	public const int DOTDOT=11;
	public const int EQUAL=12;
	public const int GE=13;
	public const int GT=14;
	public const int LBRACK=15;
	public const int LCURLY=16;
	public const int LE=17;
	public const int LPAREN=18;
	public const int LT=19;
	public const int MINUS=20;
	public const int MULT=21;
	public const int NAME=22;
	public const int NEQUAL=23;
	public const int NUMBER=24;
	public const int PLUS=25;
	public const int POUND=26;
	public const int RARROW=27;
	public const int RBRACK=28;
	public const int RCURLY=29;
	public const int RPAREN=30;
	public const int SEMICOL=31;
	public const int SL_COMMENT=32;
	public const int STRING=33;
	public const int WS=34;

	// delegates
	// delegators

	public OCLConstraintLexer()
	{
		OnCreated();
	}

	public OCLConstraintLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public OCLConstraintLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_T__35();
	partial void LeaveRule_T__35();

	// $ANTLR start "T__35"
	[GrammarRule("T__35")]
	private void mT__35()
	{
		EnterRule_T__35();
		EnterRule("T__35", 1);
		TraceIn("T__35", 1);
		try
		{
			int _type = T__35;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:10:7: ( 'and' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:10:9: 'and'
			{
			DebugLocation(10, 9);
			Match("and"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__35", 1);
			LeaveRule("T__35", 1);
			LeaveRule_T__35();
		}
	}
	// $ANTLR end "T__35"

	partial void EnterRule_T__36();
	partial void LeaveRule_T__36();

	// $ANTLR start "T__36"
	[GrammarRule("T__36")]
	private void mT__36()
	{
		EnterRule_T__36();
		EnterRule("T__36", 2);
		TraceIn("T__36", 2);
		try
		{
			int _type = T__36;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:11:7: ( 'implies' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:11:9: 'implies'
			{
			DebugLocation(11, 9);
			Match("implies"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__36", 2);
			LeaveRule("T__36", 2);
			LeaveRule_T__36();
		}
	}
	// $ANTLR end "T__36"

	partial void EnterRule_T__37();
	partial void LeaveRule_T__37();

	// $ANTLR start "T__37"
	[GrammarRule("T__37")]
	private void mT__37()
	{
		EnterRule_T__37();
		EnterRule("T__37", 3);
		TraceIn("T__37", 3);
		try
		{
			int _type = T__37;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:12:7: ( 'inv' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:12:9: 'inv'
			{
			DebugLocation(12, 9);
			Match("inv"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__37", 3);
			LeaveRule("T__37", 3);
			LeaveRule_T__37();
		}
	}
	// $ANTLR end "T__37"

	partial void EnterRule_T__38();
	partial void LeaveRule_T__38();

	// $ANTLR start "T__38"
	[GrammarRule("T__38")]
	private void mT__38()
	{
		EnterRule_T__38();
		EnterRule("T__38", 4);
		TraceIn("T__38", 4);
		try
		{
			int _type = T__38;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:13:7: ( 'not' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:13:9: 'not'
			{
			DebugLocation(13, 9);
			Match("not"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__38", 4);
			LeaveRule("T__38", 4);
			LeaveRule_T__38();
		}
	}
	// $ANTLR end "T__38"

	partial void EnterRule_T__39();
	partial void LeaveRule_T__39();

	// $ANTLR start "T__39"
	[GrammarRule("T__39")]
	private void mT__39()
	{
		EnterRule_T__39();
		EnterRule("T__39", 5);
		TraceIn("T__39", 5);
		try
		{
			int _type = T__39;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:14:7: ( 'or' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:14:9: 'or'
			{
			DebugLocation(14, 9);
			Match("or"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__39", 5);
			LeaveRule("T__39", 5);
			LeaveRule_T__39();
		}
	}
	// $ANTLR end "T__39"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 6);
		TraceIn("WS", 6);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:212:2: ( ( ' ' | '\\t' | '\\n' | '\\r' ) )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:212:4: ( ' ' | '\\t' | '\\n' | '\\r' )
			{
			DebugLocation(212, 4);
			if ((input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(216, 2);
			 _channel=Hidden; 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 6);
			LeaveRule("WS", 6);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 7);
		TraceIn("LPAREN", 7);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:219:10: ( '(' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:219:12: '('
			{
			DebugLocation(219, 12);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 7);
			LeaveRule("LPAREN", 7);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 8);
		TraceIn("RPAREN", 8);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:220:10: ( ')' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:220:12: ')'
			{
			DebugLocation(220, 12);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 8);
			LeaveRule("RPAREN", 8);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_LBRACK();
	partial void LeaveRule_LBRACK();

	// $ANTLR start "LBRACK"
	[GrammarRule("LBRACK")]
	private void mLBRACK()
	{
		EnterRule_LBRACK();
		EnterRule("LBRACK", 9);
		TraceIn("LBRACK", 9);
		try
		{
			int _type = LBRACK;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:221:10: ( '[' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:221:12: '['
			{
			DebugLocation(221, 12);
			Match('['); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LBRACK", 9);
			LeaveRule("LBRACK", 9);
			LeaveRule_LBRACK();
		}
	}
	// $ANTLR end "LBRACK"

	partial void EnterRule_RBRACK();
	partial void LeaveRule_RBRACK();

	// $ANTLR start "RBRACK"
	[GrammarRule("RBRACK")]
	private void mRBRACK()
	{
		EnterRule_RBRACK();
		EnterRule("RBRACK", 10);
		TraceIn("RBRACK", 10);
		try
		{
			int _type = RBRACK;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:222:10: ( ']' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:222:12: ']'
			{
			DebugLocation(222, 12);
			Match(']'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RBRACK", 10);
			LeaveRule("RBRACK", 10);
			LeaveRule_RBRACK();
		}
	}
	// $ANTLR end "RBRACK"

	partial void EnterRule_LCURLY();
	partial void LeaveRule_LCURLY();

	// $ANTLR start "LCURLY"
	[GrammarRule("LCURLY")]
	private void mLCURLY()
	{
		EnterRule_LCURLY();
		EnterRule("LCURLY", 11);
		TraceIn("LCURLY", 11);
		try
		{
			int _type = LCURLY;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:223:10: ( '{' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:223:12: '{'
			{
			DebugLocation(223, 12);
			Match('{'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LCURLY", 11);
			LeaveRule("LCURLY", 11);
			LeaveRule_LCURLY();
		}
	}
	// $ANTLR end "LCURLY"

	partial void EnterRule_RCURLY();
	partial void LeaveRule_RCURLY();

	// $ANTLR start "RCURLY"
	[GrammarRule("RCURLY")]
	private void mRCURLY()
	{
		EnterRule_RCURLY();
		EnterRule("RCURLY", 12);
		TraceIn("RCURLY", 12);
		try
		{
			int _type = RCURLY;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:224:10: ( '}' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:224:12: '}'
			{
			DebugLocation(224, 12);
			Match('}'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RCURLY", 12);
			LeaveRule("RCURLY", 12);
			LeaveRule_RCURLY();
		}
	}
	// $ANTLR end "RCURLY"

	partial void EnterRule_COLON();
	partial void LeaveRule_COLON();

	// $ANTLR start "COLON"
	[GrammarRule("COLON")]
	private void mCOLON()
	{
		EnterRule_COLON();
		EnterRule("COLON", 13);
		TraceIn("COLON", 13);
		try
		{
			int _type = COLON;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:225:9: ( ':' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:225:11: ':'
			{
			DebugLocation(225, 11);
			Match(':'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COLON", 13);
			LeaveRule("COLON", 13);
			LeaveRule_COLON();
		}
	}
	// $ANTLR end "COLON"

	partial void EnterRule_DCOLON();
	partial void LeaveRule_DCOLON();

	// $ANTLR start "DCOLON"
	[GrammarRule("DCOLON")]
	private void mDCOLON()
	{
		EnterRule_DCOLON();
		EnterRule("DCOLON", 14);
		TraceIn("DCOLON", 14);
		try
		{
			int _type = DCOLON;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:226:10: ( '::' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:226:12: '::'
			{
			DebugLocation(226, 12);
			Match("::"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DCOLON", 14);
			LeaveRule("DCOLON", 14);
			LeaveRule_DCOLON();
		}
	}
	// $ANTLR end "DCOLON"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 15);
		TraceIn("COMMA", 15);
		try
		{
			int _type = COMMA;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:227:9: ( ',' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:227:11: ','
			{
			DebugLocation(227, 11);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMA", 15);
			LeaveRule("COMMA", 15);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_EQUAL();
	partial void LeaveRule_EQUAL();

	// $ANTLR start "EQUAL"
	[GrammarRule("EQUAL")]
	private void mEQUAL()
	{
		EnterRule_EQUAL();
		EnterRule("EQUAL", 16);
		TraceIn("EQUAL", 16);
		try
		{
			int _type = EQUAL;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:228:9: ( '=' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:228:11: '='
			{
			DebugLocation(228, 11);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQUAL", 16);
			LeaveRule("EQUAL", 16);
			LeaveRule_EQUAL();
		}
	}
	// $ANTLR end "EQUAL"

	partial void EnterRule_NEQUAL();
	partial void LeaveRule_NEQUAL();

	// $ANTLR start "NEQUAL"
	[GrammarRule("NEQUAL")]
	private void mNEQUAL()
	{
		EnterRule_NEQUAL();
		EnterRule("NEQUAL", 17);
		TraceIn("NEQUAL", 17);
		try
		{
			int _type = NEQUAL;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:229:10: ( '<>' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:229:12: '<>'
			{
			DebugLocation(229, 12);
			Match("<>"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEQUAL", 17);
			LeaveRule("NEQUAL", 17);
			LeaveRule_NEQUAL();
		}
	}
	// $ANTLR end "NEQUAL"

	partial void EnterRule_LT();
	partial void LeaveRule_LT();

	// $ANTLR start "LT"
	[GrammarRule("LT")]
	private void mLT()
	{
		EnterRule_LT();
		EnterRule("LT", 18);
		TraceIn("LT", 18);
		try
		{
			int _type = LT;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:230:7: ( '<' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:230:9: '<'
			{
			DebugLocation(230, 9);
			Match('<'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LT", 18);
			LeaveRule("LT", 18);
			LeaveRule_LT();
		}
	}
	// $ANTLR end "LT"

	partial void EnterRule_GT();
	partial void LeaveRule_GT();

	// $ANTLR start "GT"
	[GrammarRule("GT")]
	private void mGT()
	{
		EnterRule_GT();
		EnterRule("GT", 19);
		TraceIn("GT", 19);
		try
		{
			int _type = GT;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:231:7: ( '>' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:231:9: '>'
			{
			DebugLocation(231, 9);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GT", 19);
			LeaveRule("GT", 19);
			LeaveRule_GT();
		}
	}
	// $ANTLR end "GT"

	partial void EnterRule_LE();
	partial void LeaveRule_LE();

	// $ANTLR start "LE"
	[GrammarRule("LE")]
	private void mLE()
	{
		EnterRule_LE();
		EnterRule("LE", 20);
		TraceIn("LE", 20);
		try
		{
			int _type = LE;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:232:7: ( '<=' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:232:9: '<='
			{
			DebugLocation(232, 9);
			Match("<="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LE", 20);
			LeaveRule("LE", 20);
			LeaveRule_LE();
		}
	}
	// $ANTLR end "LE"

	partial void EnterRule_GE();
	partial void LeaveRule_GE();

	// $ANTLR start "GE"
	[GrammarRule("GE")]
	private void mGE()
	{
		EnterRule_GE();
		EnterRule("GE", 21);
		TraceIn("GE", 21);
		try
		{
			int _type = GE;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:233:7: ( '>=' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:233:9: '>='
			{
			DebugLocation(233, 9);
			Match(">="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GE", 21);
			LeaveRule("GE", 21);
			LeaveRule_GE();
		}
	}
	// $ANTLR end "GE"

	partial void EnterRule_RARROW();
	partial void LeaveRule_RARROW();

	// $ANTLR start "RARROW"
	[GrammarRule("RARROW")]
	private void mRARROW()
	{
		EnterRule_RARROW();
		EnterRule("RARROW", 22);
		TraceIn("RARROW", 22);
		try
		{
			int _type = RARROW;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:234:10: ( '->' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:234:12: '->'
			{
			DebugLocation(234, 12);
			Match("->"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RARROW", 22);
			LeaveRule("RARROW", 22);
			LeaveRule_RARROW();
		}
	}
	// $ANTLR end "RARROW"

	partial void EnterRule_DOTDOT();
	partial void LeaveRule_DOTDOT();

	// $ANTLR start "DOTDOT"
	[GrammarRule("DOTDOT")]
	private void mDOTDOT()
	{
		EnterRule_DOTDOT();
		EnterRule("DOTDOT", 23);
		TraceIn("DOTDOT", 23);
		try
		{
			int _type = DOTDOT;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:235:10: ( '..' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:235:12: '..'
			{
			DebugLocation(235, 12);
			Match(".."); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOTDOT", 23);
			LeaveRule("DOTDOT", 23);
			LeaveRule_DOTDOT();
		}
	}
	// $ANTLR end "DOTDOT"

	partial void EnterRule_DOT();
	partial void LeaveRule_DOT();

	// $ANTLR start "DOT"
	[GrammarRule("DOT")]
	private void mDOT()
	{
		EnterRule_DOT();
		EnterRule("DOT", 24);
		TraceIn("DOT", 24);
		try
		{
			int _type = DOT;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:236:8: ( '.' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:236:10: '.'
			{
			DebugLocation(236, 10);
			Match('.'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOT", 24);
			LeaveRule("DOT", 24);
			LeaveRule_DOT();
		}
	}
	// $ANTLR end "DOT"

	partial void EnterRule_POUND();
	partial void LeaveRule_POUND();

	// $ANTLR start "POUND"
	[GrammarRule("POUND")]
	private void mPOUND()
	{
		EnterRule_POUND();
		EnterRule("POUND", 25);
		TraceIn("POUND", 25);
		try
		{
			int _type = POUND;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:237:9: ( '#' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:237:11: '#'
			{
			DebugLocation(237, 11);
			Match('#'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("POUND", 25);
			LeaveRule("POUND", 25);
			LeaveRule_POUND();
		}
	}
	// $ANTLR end "POUND"

	partial void EnterRule_SEMICOL();
	partial void LeaveRule_SEMICOL();

	// $ANTLR start "SEMICOL"
	[GrammarRule("SEMICOL")]
	private void mSEMICOL()
	{
		EnterRule_SEMICOL();
		EnterRule("SEMICOL", 26);
		TraceIn("SEMICOL", 26);
		try
		{
			int _type = SEMICOL;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:238:11: ( ';' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:238:13: ';'
			{
			DebugLocation(238, 13);
			Match(';'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SEMICOL", 26);
			LeaveRule("SEMICOL", 26);
			LeaveRule_SEMICOL();
		}
	}
	// $ANTLR end "SEMICOL"

	partial void EnterRule_BAR();
	partial void LeaveRule_BAR();

	// $ANTLR start "BAR"
	[GrammarRule("BAR")]
	private void mBAR()
	{
		EnterRule_BAR();
		EnterRule("BAR", 27);
		TraceIn("BAR", 27);
		try
		{
			int _type = BAR;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:239:8: ( '|' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:239:10: '|'
			{
			DebugLocation(239, 10);
			Match('|'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BAR", 27);
			LeaveRule("BAR", 27);
			LeaveRule_BAR();
		}
	}
	// $ANTLR end "BAR"

	partial void EnterRule_ATSIGN();
	partial void LeaveRule_ATSIGN();

	// $ANTLR start "ATSIGN"
	[GrammarRule("ATSIGN")]
	private void mATSIGN()
	{
		EnterRule_ATSIGN();
		EnterRule("ATSIGN", 28);
		TraceIn("ATSIGN", 28);
		try
		{
			int _type = ATSIGN;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:240:10: ( '@' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:240:12: '@'
			{
			DebugLocation(240, 12);
			Match('@'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ATSIGN", 28);
			LeaveRule("ATSIGN", 28);
			LeaveRule_ATSIGN();
		}
	}
	// $ANTLR end "ATSIGN"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 29);
		TraceIn("PLUS", 29);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:241:8: ( '+' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:241:10: '+'
			{
			DebugLocation(241, 10);
			Match('+'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 29);
			LeaveRule("PLUS", 29);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 30);
		TraceIn("MINUS", 30);
		try
		{
			int _type = MINUS;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:242:9: ( '-' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:242:11: '-'
			{
			DebugLocation(242, 11);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MINUS", 30);
			LeaveRule("MINUS", 30);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_MULT();
	partial void LeaveRule_MULT();

	// $ANTLR start "MULT"
	[GrammarRule("MULT")]
	private void mMULT()
	{
		EnterRule_MULT();
		EnterRule("MULT", 31);
		TraceIn("MULT", 31);
		try
		{
			int _type = MULT;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:243:8: ( '*' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:243:10: '*'
			{
			DebugLocation(243, 10);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MULT", 31);
			LeaveRule("MULT", 31);
			LeaveRule_MULT();
		}
	}
	// $ANTLR end "MULT"

	partial void EnterRule_DIVIDE();
	partial void LeaveRule_DIVIDE();

	// $ANTLR start "DIVIDE"
	[GrammarRule("DIVIDE")]
	private void mDIVIDE()
	{
		EnterRule_DIVIDE();
		EnterRule("DIVIDE", 32);
		TraceIn("DIVIDE", 32);
		try
		{
			int _type = DIVIDE;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:244:10: ( '/' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:244:12: '/'
			{
			DebugLocation(244, 12);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIVIDE", 32);
			LeaveRule("DIVIDE", 32);
			LeaveRule_DIVIDE();
		}
	}
	// $ANTLR end "DIVIDE"

	partial void EnterRule_NAME();
	partial void LeaveRule_NAME();

	// $ANTLR start "NAME"
	[GrammarRule("NAME")]
	private void mNAME()
	{
		EnterRule_NAME();
		EnterRule("NAME", 33);
		TraceIn("NAME", 33);
		try
		{
			int _type = NAME;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:247:5: ( ( ( 'a' .. 'z' ) | ( 'A' .. 'Z' ) | ( '_' ) ) ( ( 'a' .. 'z' ) | ( '0' .. '9' ) | ( 'A' .. 'Z' ) | ( '_' ) )* )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:247:7: ( ( 'a' .. 'z' ) | ( 'A' .. 'Z' ) | ( '_' ) ) ( ( 'a' .. 'z' ) | ( '0' .. '9' ) | ( 'A' .. 'Z' ) | ( '_' ) )*
			{
			DebugLocation(247, 7);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(248, 9);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:248:9: ( ( 'a' .. 'z' ) | ( '0' .. '9' ) | ( 'A' .. 'Z' ) | ( '_' ) )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>='0' && LA1_1<='9')||(LA1_1>='A' && LA1_1<='Z')||LA1_1=='_'||(LA1_1>='a' && LA1_1<='z')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:
					{
					DebugLocation(248, 9);
					input.Consume();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NAME", 33);
			LeaveRule("NAME", 33);
			LeaveRule_NAME();
		}
	}
	// $ANTLR end "NAME"

	partial void EnterRule_NUMBER();
	partial void LeaveRule_NUMBER();

	// $ANTLR start "NUMBER"
	[GrammarRule("NUMBER")]
	private void mNUMBER()
	{
		EnterRule_NUMBER();
		EnterRule("NUMBER", 34);
		TraceIn("NUMBER", 34);
		try
		{
			int _type = NUMBER;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:252:3: ( ( '0' .. '9' )+ ({...}? '.' ( '0' .. '9' )+ )? ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )? )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:252:5: ( '0' .. '9' )+ ({...}? '.' ( '0' .. '9' )+ )? ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )?
			{
			DebugLocation(252, 5);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:252:5: ( '0' .. '9' )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if (((LA2_1>='0' && LA2_1<='9')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:
					{
					DebugLocation(252, 5);
					input.Consume();


					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(253, 5);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:253:5: ({...}? '.' ( '0' .. '9' )+ )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1=='.'))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:253:7: {...}? '.' ( '0' .. '9' )+
				{
				DebugLocation(253, 7);
				if (!(( input.LA(2) != '.' )))
				{
					throw new FailedPredicateException(input, "NUMBER", " input.LA(2) != '.' ");
				}
				DebugLocation(253, 31);
				Match('.'); 
				DebugLocation(253, 35);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:253:35: ( '0' .. '9' )+
				int cnt3=0;
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_1 = input.LA(1);

					if (((LA3_1>='0' && LA3_1<='9')))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch (alt3)
					{
					case 1:
						DebugEnterAlt(1);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:
						{
						DebugLocation(253, 35);
						input.Consume();


						}
						break;

					default:
						if (cnt3 >= 1)
							goto loop3;

						EarlyExitException eee3 = new EarlyExitException( 3, input );
						DebugRecognitionException(eee3);
						throw eee3;
					}
					cnt3++;
				}
				loop3:
					;

				} finally { DebugExitSubRule(3); }


				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(254, 5);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:254:5: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1=='E'||LA7_1=='e'))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:254:7: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
				{
				DebugLocation(254, 7);
				input.Consume();

				DebugLocation(254, 19);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:254:19: ( '+' | '-' )?
				int alt5=2;
				try { DebugEnterSubRule(5);
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1=='+'||LA5_1=='-'))
				{
					alt5 = 1;
				}
				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:
					{
					DebugLocation(254, 19);
					input.Consume();


					}
					break;

				}
				} finally { DebugExitSubRule(5); }

				DebugLocation(254, 32);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:254:32: ( '0' .. '9' )+
				int cnt6=0;
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_1 = input.LA(1);

					if (((LA6_1>='0' && LA6_1<='9')))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:
						{
						DebugLocation(254, 32);
						input.Consume();


						}
						break;

					default:
						if (cnt6 >= 1)
							goto loop6;

						EarlyExitException eee6 = new EarlyExitException( 6, input );
						DebugRecognitionException(eee6);
						throw eee6;
					}
					cnt6++;
				}
				loop6:
					;

				} finally { DebugExitSubRule(6); }


				}
				break;

			}
			} finally { DebugExitSubRule(7); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NUMBER", 34);
			LeaveRule("NUMBER", 34);
			LeaveRule_NUMBER();
		}
	}
	// $ANTLR end "NUMBER"

	partial void EnterRule_STRING();
	partial void LeaveRule_STRING();

	// $ANTLR start "STRING"
	[GrammarRule("STRING")]
	private void mSTRING()
	{
		EnterRule_STRING();
		EnterRule("STRING", 35);
		TraceIn("STRING", 35);
		try
		{
			int _type = STRING;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:257:8: ( '\\'' ( (~ ( '\\'' | '\\\\' | '\\n' | '\\r' ) ) | ( '\\\\' ( ( 'n' | 't' | 'b' | 'r' | 'f' | '\\\\' | '\\'' | '\\\"' ) | ( '0' .. '3' ) ( ( '0' .. '7' ) ( '0' .. '7' )? )? | ( '4' .. '7' ) ( ( '0' .. '9' ) )? ) ) )* '\\'' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:257:10: '\\'' ( (~ ( '\\'' | '\\\\' | '\\n' | '\\r' ) ) | ( '\\\\' ( ( 'n' | 't' | 'b' | 'r' | 'f' | '\\\\' | '\\'' | '\\\"' ) | ( '0' .. '3' ) ( ( '0' .. '7' ) ( '0' .. '7' )? )? | ( '4' .. '7' ) ( ( '0' .. '9' ) )? ) ) )* '\\''
			{
			DebugLocation(257, 10);
			Match('\''); 
			DebugLocation(258, 2);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:258:2: ( (~ ( '\\'' | '\\\\' | '\\n' | '\\r' ) ) | ( '\\\\' ( ( 'n' | 't' | 'b' | 'r' | 'f' | '\\\\' | '\\'' | '\\\"' ) | ( '0' .. '3' ) ( ( '0' .. '7' ) ( '0' .. '7' )? )? | ( '4' .. '7' ) ( ( '0' .. '9' ) )? ) ) )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=3;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if (((LA12_1>='\u0000' && LA12_1<='\t')||(LA12_1>='\u000B' && LA12_1<='\f')||(LA12_1>='\u000E' && LA12_1<='&')||(LA12_1>='(' && LA12_1<='[')||(LA12_1>=']' && LA12_1<='\uFFFF')))
				{
					alt12 = 1;
				}
				else if ((LA12_1=='\\'))
				{
					alt12 = 2;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:259:2: (~ ( '\\'' | '\\\\' | '\\n' | '\\r' ) )
					{
					DebugLocation(259, 2);
					input.Consume();


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:260:4: ( '\\\\' ( ( 'n' | 't' | 'b' | 'r' | 'f' | '\\\\' | '\\'' | '\\\"' ) | ( '0' .. '3' ) ( ( '0' .. '7' ) ( '0' .. '7' )? )? | ( '4' .. '7' ) ( ( '0' .. '9' ) )? ) )
					{
					DebugLocation(260, 4);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:260:4: ( '\\\\' ( ( 'n' | 't' | 'b' | 'r' | 'f' | '\\\\' | '\\'' | '\\\"' ) | ( '0' .. '3' ) ( ( '0' .. '7' ) ( '0' .. '7' )? )? | ( '4' .. '7' ) ( ( '0' .. '9' ) )? ) )
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:260:5: '\\\\' ( ( 'n' | 't' | 'b' | 'r' | 'f' | '\\\\' | '\\'' | '\\\"' ) | ( '0' .. '3' ) ( ( '0' .. '7' ) ( '0' .. '7' )? )? | ( '4' .. '7' ) ( ( '0' .. '9' ) )? )
					{
					DebugLocation(260, 5);
					Match('\\'); 
					DebugLocation(260, 10);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:260:10: ( ( 'n' | 't' | 'b' | 'r' | 'f' | '\\\\' | '\\'' | '\\\"' ) | ( '0' .. '3' ) ( ( '0' .. '7' ) ( '0' .. '7' )? )? | ( '4' .. '7' ) ( ( '0' .. '9' ) )? )
					int alt11=3;
					try { DebugEnterSubRule(11);
					try { DebugEnterDecision(11, false);
					switch (input.LA(1))
					{
					case '\"':
					case '\'':
					case '\\':
					case 'b':
					case 'f':
					case 'n':
					case 'r':
					case 't':
						{
						alt11 = 1;
						}
						break;
					case '0':
					case '1':
					case '2':
					case '3':
						{
						alt11 = 2;
						}
						break;
					case '4':
					case '5':
					case '6':
					case '7':
						{
						alt11 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:260:12: ( 'n' | 't' | 'b' | 'r' | 'f' | '\\\\' | '\\'' | '\\\"' )
						{
						DebugLocation(260, 12);
						input.Consume();


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:261:5: ( '0' .. '3' ) ( ( '0' .. '7' ) ( '0' .. '7' )? )?
						{
						DebugLocation(261, 5);
						input.Consume();

						DebugLocation(262, 5);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:262:5: ( ( '0' .. '7' ) ( '0' .. '7' )? )?
						int alt9=2;
						try { DebugEnterSubRule(9);
						try { DebugEnterDecision(9, false);
						int LA9_1 = input.LA(1);

						if (((LA9_1>='0' && LA9_1<='7')))
						{
							alt9 = 1;
						}
						} finally { DebugExitDecision(9); }
						switch (alt9)
						{
						case 1:
							DebugEnterAlt(1);
							// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:262:6: ( '0' .. '7' ) ( '0' .. '7' )?
							{
							DebugLocation(262, 6);
							input.Consume();

							DebugLocation(263, 4);
							// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:263:4: ( '0' .. '7' )?
							int alt8=2;
							try { DebugEnterSubRule(8);
							try { DebugEnterDecision(8, false);
							int LA8_1 = input.LA(1);

							if (((LA8_1>='0' && LA8_1<='7')))
							{
								alt8 = 1;
							}
							} finally { DebugExitDecision(8); }
							switch (alt8)
							{
							case 1:
								DebugEnterAlt(1);
								// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:
								{
								DebugLocation(263, 4);
								input.Consume();


								}
								break;

							}
							} finally { DebugExitSubRule(8); }


							}
							break;

						}
						} finally { DebugExitSubRule(9); }


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:265:5: ( '4' .. '7' ) ( ( '0' .. '9' ) )?
						{
						DebugLocation(265, 5);
						input.Consume();

						DebugLocation(266, 5);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:266:5: ( ( '0' .. '9' ) )?
						int alt10=2;
						try { DebugEnterSubRule(10);
						try { DebugEnterDecision(10, false);
						int LA10_1 = input.LA(1);

						if (((LA10_1>='0' && LA10_1<='9')))
						{
							alt10 = 1;
						}
						} finally { DebugExitDecision(10); }
						switch (alt10)
						{
						case 1:
							DebugEnterAlt(1);
							// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:
							{
							DebugLocation(266, 5);
							input.Consume();


							}
							break;

						}
						} finally { DebugExitSubRule(10); }


						}
						break;

					}
					} finally { DebugExitSubRule(11); }


					}


					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(269, 2);
			Match('\''); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING", 35);
			LeaveRule("STRING", 35);
			LeaveRule_STRING();
		}
	}
	// $ANTLR end "STRING"

	partial void EnterRule_SL_COMMENT();
	partial void LeaveRule_SL_COMMENT();

	// $ANTLR start "SL_COMMENT"
	[GrammarRule("SL_COMMENT")]
	private void mSL_COMMENT()
	{
		EnterRule_SL_COMMENT();
		EnterRule("SL_COMMENT", 36);
		TraceIn("SL_COMMENT", 36);
		try
		{
			int _type = SL_COMMENT;
			int _channel = DefaultTokenChannel;
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:272:11: ( '--' (~ '\\n' )* '\\n' )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:272:13: '--' (~ '\\n' )* '\\n'
			{
			DebugLocation(272, 13);
			Match("--"); 

			DebugLocation(272, 18);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:272:18: (~ '\\n' )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if (((LA13_1>='\u0000' && LA13_1<='\t')||(LA13_1>='\u000B' && LA13_1<='\uFFFF')))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:
					{
					DebugLocation(272, 18);
					input.Consume();


					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(272, 27);
			Match('\n'); 
			DebugLocation(273, 2);
			_channel=Hidden;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SL_COMMENT", 36);
			LeaveRule("SL_COMMENT", 36);
			LeaveRule_SL_COMMENT();
		}
	}
	// $ANTLR end "SL_COMMENT"

	public override void mTokens()
	{
		// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:8: ( T__35 | T__36 | T__37 | T__38 | T__39 | WS | LPAREN | RPAREN | LBRACK | RBRACK | LCURLY | RCURLY | COLON | DCOLON | COMMA | EQUAL | NEQUAL | LT | GT | LE | GE | RARROW | DOTDOT | DOT | POUND | SEMICOL | BAR | ATSIGN | PLUS | MINUS | MULT | DIVIDE | NAME | NUMBER | STRING | SL_COMMENT )
		int alt14=36;
		try { DebugEnterDecision(14, false);
		switch (input.LA(1))
		{
		case 'a':
			{
			int LA14_2 = input.LA(2);

			if ((LA14_2=='n'))
			{
				int LA14_3 = input.LA(3);

				if ((LA14_3=='d'))
				{
					int LA14_4 = input.LA(4);

					if (((LA14_4>='0' && LA14_4<='9')||(LA14_4>='A' && LA14_4<='Z')||LA14_4=='_'||(LA14_4>='a' && LA14_4<='z')))
					{
						alt14 = 33;
					}
					else
					{
						alt14 = 1;
					}
				}
				else
				{
					alt14 = 33;
				}
			}
			else
			{
				alt14 = 33;
			}
			}
			break;
		case 'i':
			{
			switch (input.LA(2))
			{
			case 'm':
				{
				int LA14_3 = input.LA(3);

				if ((LA14_3=='p'))
				{
					int LA14_4 = input.LA(4);

					if ((LA14_4=='l'))
					{
						int LA14_5 = input.LA(5);

						if ((LA14_5=='i'))
						{
							int LA14_6 = input.LA(6);

							if ((LA14_6=='e'))
							{
								int LA14_7 = input.LA(7);

								if ((LA14_7=='s'))
								{
									int LA14_8 = input.LA(8);

									if (((LA14_8>='0' && LA14_8<='9')||(LA14_8>='A' && LA14_8<='Z')||LA14_8=='_'||(LA14_8>='a' && LA14_8<='z')))
									{
										alt14 = 33;
									}
									else
									{
										alt14 = 2;
									}
								}
								else
								{
									alt14 = 33;
								}
							}
							else
							{
								alt14 = 33;
							}
						}
						else
						{
							alt14 = 33;
						}
					}
					else
					{
						alt14 = 33;
					}
				}
				else
				{
					alt14 = 33;
				}
				}
				break;
			case 'n':
				{
				int LA14_3 = input.LA(3);

				if ((LA14_3=='v'))
				{
					int LA14_4 = input.LA(4);

					if (((LA14_4>='0' && LA14_4<='9')||(LA14_4>='A' && LA14_4<='Z')||LA14_4=='_'||(LA14_4>='a' && LA14_4<='z')))
					{
						alt14 = 33;
					}
					else
					{
						alt14 = 3;
					}
				}
				else
				{
					alt14 = 33;
				}
				}
				break;
			default:
				alt14=33;
				break;

			}

			}
			break;
		case 'n':
			{
			int LA14_2 = input.LA(2);

			if ((LA14_2=='o'))
			{
				int LA14_3 = input.LA(3);

				if ((LA14_3=='t'))
				{
					int LA14_4 = input.LA(4);

					if (((LA14_4>='0' && LA14_4<='9')||(LA14_4>='A' && LA14_4<='Z')||LA14_4=='_'||(LA14_4>='a' && LA14_4<='z')))
					{
						alt14 = 33;
					}
					else
					{
						alt14 = 4;
					}
				}
				else
				{
					alt14 = 33;
				}
			}
			else
			{
				alt14 = 33;
			}
			}
			break;
		case 'o':
			{
			int LA14_2 = input.LA(2);

			if ((LA14_2=='r'))
			{
				int LA14_3 = input.LA(3);

				if (((LA14_3>='0' && LA14_3<='9')||(LA14_3>='A' && LA14_3<='Z')||LA14_3=='_'||(LA14_3>='a' && LA14_3<='z')))
				{
					alt14 = 33;
				}
				else
				{
					alt14 = 5;
				}
			}
			else
			{
				alt14 = 33;
			}
			}
			break;
		case '\t':
		case '\n':
		case '\r':
		case ' ':
			{
			alt14 = 6;
			}
			break;
		case '(':
			{
			alt14 = 7;
			}
			break;
		case ')':
			{
			alt14 = 8;
			}
			break;
		case '[':
			{
			alt14 = 9;
			}
			break;
		case ']':
			{
			alt14 = 10;
			}
			break;
		case '{':
			{
			alt14 = 11;
			}
			break;
		case '}':
			{
			alt14 = 12;
			}
			break;
		case ':':
			{
			int LA14_2 = input.LA(2);

			if ((LA14_2==':'))
			{
				alt14 = 14;
			}
			else
			{
				alt14 = 13;
			}
			}
			break;
		case ',':
			{
			alt14 = 15;
			}
			break;
		case '=':
			{
			alt14 = 16;
			}
			break;
		case '<':
			{
			switch (input.LA(2))
			{
			case '>':
				{
				alt14 = 17;
				}
				break;
			case '=':
				{
				alt14 = 20;
				}
				break;
			default:
				alt14=18;
				break;

			}

			}
			break;
		case '>':
			{
			int LA14_2 = input.LA(2);

			if ((LA14_2=='='))
			{
				alt14 = 21;
			}
			else
			{
				alt14 = 19;
			}
			}
			break;
		case '-':
			{
			switch (input.LA(2))
			{
			case '>':
				{
				alt14 = 22;
				}
				break;
			case '-':
				{
				alt14 = 36;
				}
				break;
			default:
				alt14=30;
				break;

			}

			}
			break;
		case '.':
			{
			int LA14_2 = input.LA(2);

			if ((LA14_2=='.'))
			{
				alt14 = 23;
			}
			else
			{
				alt14 = 24;
			}
			}
			break;
		case '#':
			{
			alt14 = 25;
			}
			break;
		case ';':
			{
			alt14 = 26;
			}
			break;
		case '|':
			{
			alt14 = 27;
			}
			break;
		case '@':
			{
			alt14 = 28;
			}
			break;
		case '+':
			{
			alt14 = 29;
			}
			break;
		case '*':
			{
			alt14 = 31;
			}
			break;
		case '/':
			{
			alt14 = 32;
			}
			break;
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':
			{
			alt14 = 33;
			}
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			{
			alt14 = 34;
			}
			break;
		case '\'':
			{
			alt14 = 35;
			}
			break;
		default:
			{
				NoViableAltException nvae = new NoViableAltException("", 14, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}

		} finally { DebugExitDecision(14); }
		switch (alt14)
		{
		case 1:
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:10: T__35
			{
			DebugLocation(1, 10);
			mT__35(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:16: T__36
			{
			DebugLocation(1, 16);
			mT__36(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:22: T__37
			{
			DebugLocation(1, 22);
			mT__37(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:28: T__38
			{
			DebugLocation(1, 28);
			mT__38(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:34: T__39
			{
			DebugLocation(1, 34);
			mT__39(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:40: WS
			{
			DebugLocation(1, 40);
			mWS(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:43: LPAREN
			{
			DebugLocation(1, 43);
			mLPAREN(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:50: RPAREN
			{
			DebugLocation(1, 50);
			mRPAREN(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:57: LBRACK
			{
			DebugLocation(1, 57);
			mLBRACK(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:64: RBRACK
			{
			DebugLocation(1, 64);
			mRBRACK(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:71: LCURLY
			{
			DebugLocation(1, 71);
			mLCURLY(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:78: RCURLY
			{
			DebugLocation(1, 78);
			mRCURLY(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:85: COLON
			{
			DebugLocation(1, 85);
			mCOLON(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:91: DCOLON
			{
			DebugLocation(1, 91);
			mDCOLON(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:98: COMMA
			{
			DebugLocation(1, 98);
			mCOMMA(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:104: EQUAL
			{
			DebugLocation(1, 104);
			mEQUAL(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:110: NEQUAL
			{
			DebugLocation(1, 110);
			mNEQUAL(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:117: LT
			{
			DebugLocation(1, 117);
			mLT(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:120: GT
			{
			DebugLocation(1, 120);
			mGT(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:123: LE
			{
			DebugLocation(1, 123);
			mLE(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:126: GE
			{
			DebugLocation(1, 126);
			mGE(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:129: RARROW
			{
			DebugLocation(1, 129);
			mRARROW(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:136: DOTDOT
			{
			DebugLocation(1, 136);
			mDOTDOT(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:143: DOT
			{
			DebugLocation(1, 143);
			mDOT(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:147: POUND
			{
			DebugLocation(1, 147);
			mPOUND(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:153: SEMICOL
			{
			DebugLocation(1, 153);
			mSEMICOL(); 

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:161: BAR
			{
			DebugLocation(1, 161);
			mBAR(); 

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:165: ATSIGN
			{
			DebugLocation(1, 165);
			mATSIGN(); 

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:172: PLUS
			{
			DebugLocation(1, 172);
			mPLUS(); 

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:177: MINUS
			{
			DebugLocation(1, 177);
			mMINUS(); 

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:183: MULT
			{
			DebugLocation(1, 183);
			mMULT(); 

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:188: DIVIDE
			{
			DebugLocation(1, 188);
			mDIVIDE(); 

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:195: NAME
			{
			DebugLocation(1, 195);
			mNAME(); 

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:200: NUMBER
			{
			DebugLocation(1, 200);
			mNUMBER(); 

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:207: STRING
			{
			DebugLocation(1, 207);
			mSTRING(); 

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:1:214: SL_COMMENT
			{
			DebugLocation(1, 214);
			mSL_COMMENT(); 

			}
			break;

		}

	}


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

	#endregion

}

} // namespace OCLtoSQL
