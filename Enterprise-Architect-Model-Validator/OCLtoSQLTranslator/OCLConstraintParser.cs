//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: null
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR null Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g 2023-05-25 17:11:32

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace OCLtoSQL
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "null")]
[System.CLSCompliant(false)]
public partial class OCLConstraintParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ATSIGN", "BAR", "COLON", "COMMA", "DCOLON", "DIVIDE", "DOT", "DOTDOT", "EQUAL", "GE", "GT", "LBRACK", "LCURLY", "LE", "LPAREN", "LT", "MINUS", "MULT", "NAME", "NEQUAL", "NUMBER", "PLUS", "POUND", "RARROW", "RBRACK", "RCURLY", "RPAREN", "SEMICOL", "SL_COMMENT", "STRING", "WS", "'and'", "'implies'", "'inv'", "'not'", "'or'"
	};
	public const int EOF=-1;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int ATSIGN=4;
	public const int BAR=5;
	public const int COLON=6;
	public const int COMMA=7;
	public const int DCOLON=8;
	public const int DIVIDE=9;
	public const int DOT=10;
	public const int DOTDOT=11;
	public const int EQUAL=12;
	public const int GE=13;
	public const int GT=14;
	public const int LBRACK=15;
	public const int LCURLY=16;
	public const int LE=17;
	public const int LPAREN=18;
	public const int LT=19;
	public const int MINUS=20;
	public const int MULT=21;
	public const int NAME=22;
	public const int NEQUAL=23;
	public const int NUMBER=24;
	public const int PLUS=25;
	public const int POUND=26;
	public const int RARROW=27;
	public const int RBRACK=28;
	public const int RCURLY=29;
	public const int RPAREN=30;
	public const int SEMICOL=31;
	public const int SL_COMMENT=32;
	public const int STRING=33;
	public const int WS=34;

	public OCLConstraintParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public OCLConstraintParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return OCLConstraintParser.tokenNames; } }
	public override string GrammarFileName { get { return "Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g"; } }

	 
		//End after first mistake (no recovery)
		protected override object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow) 
		{ 
				throw new MismatchedTokenException(ttype, input); 
		}
		public override object RecoverFromMismatchedSet(IIntStream input, 
		RecognitionException e, BitSet follow) 
		{ 
				throw e; 
		}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_constraint();
	partial void LeaveRule_constraint();
	// $ANTLR start "constraint"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:35:1: public constraint[DDLPackage ddlPackage, string context] returns [Expression expression] : 'inv' COLON lo= logicalExpression EOF ;
	[GrammarRule("constraint")]
	public Expression constraint(DDLPackage ddlPackage, string context)
	{
		EnterRule_constraint();
		EnterRule("constraint", 1);
		TraceIn("constraint", 1);
		Expression expression = default(Expression);


		Expression lo = default(Expression);


				this.ddlPackage = ddlPackage;
				defaultContext = context;
				tableBindings.Add(new TableBinding("self", context, "SELFT"));
			
		try { DebugEnterRule(GrammarFileName, "constraint");
		DebugLocation(35, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:42:3: ( 'inv' COLON lo= logicalExpression EOF )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:42:5: 'inv' COLON lo= logicalExpression EOF
			{
			DebugLocation(42, 5);
			Match(input,37,Follow._37_in_constraint79); if (state.failed) return expression;
			DebugLocation(42, 11);
			Match(input,COLON,Follow._COLON_in_constraint81); if (state.failed) return expression;
			DebugLocation(42, 19);
			PushFollow(Follow._logicalExpression_in_constraint85);
			lo=logicalExpression();
			PopFollow();
			if (state.failed) return expression;
			DebugLocation(42, 38);
			Match(input,EOF,Follow._EOF_in_constraint87); if (state.failed) return expression;
			DebugLocation(42, 42);
			if (state.backtracking == 0)
			{
				expression = lo;
			}

			}

		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("constraint", 1);
			LeaveRule("constraint", 1);
			LeaveRule_constraint();
		}
		DebugLocation(43, 2);
		} finally { DebugExitRule(GrammarFileName, "constraint"); }
		return expression;

	}
	// $ANTLR end "constraint"

	partial void EnterRule_logicalExpression();
	partial void LeaveRule_logicalExpression();
	// $ANTLR start "logicalExpression"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:45:1: logicalExpression returns [Expression expression] : e1= relationalExpression (op= logicalOperator e2= relationalExpression )* ;
	[GrammarRule("logicalExpression")]
	private Expression logicalExpression()
	{
		EnterRule_logicalExpression();
		EnterRule("logicalExpression", 2);
		TraceIn("logicalExpression", 2);
		Expression expression = default(Expression);


		Expression e1 = default(Expression);
		string op = default(string);
		Expression e2 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "logicalExpression");
		DebugLocation(45, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:46:3: (e1= relationalExpression (op= logicalOperator e2= relationalExpression )* )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:46:5: e1= relationalExpression (op= logicalOperator e2= relationalExpression )*
			{
			DebugLocation(46, 7);
			PushFollow(Follow._relationalExpression_in_logicalExpression108);
			e1=relationalExpression();
			PopFollow();
			if (state.failed) return expression;
			DebugLocation(47, 3);
			if (state.backtracking == 0)
			{

							expression = new LogicalExpression(e1);
						
			}
			DebugLocation(50, 5);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:50:5: (op= logicalOperator e2= relationalExpression )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>=35 && LA1_1<=36)||LA1_1==39))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:50:7: op= logicalOperator e2= relationalExpression
					{
					DebugLocation(50, 9);
					PushFollow(Follow._logicalOperator_in_logicalExpression122);
					op=logicalOperator();
					PopFollow();
					if (state.failed) return expression;
					DebugLocation(50, 28);
					PushFollow(Follow._relationalExpression_in_logicalExpression126);
					e2=relationalExpression();
					PopFollow();
					if (state.failed) return expression;
					DebugLocation(51, 3);
					if (state.backtracking == 0)
					{

									((LogicalExpression)expression).Add(op, e2);
								
					}

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("logicalExpression", 2);
			LeaveRule("logicalExpression", 2);
			LeaveRule_logicalExpression();
		}
		DebugLocation(55, 2);
		} finally { DebugExitRule(GrammarFileName, "logicalExpression"); }
		return expression;

	}
	// $ANTLR end "logicalExpression"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:57:1: relationalExpression returns [Expression expression] : e1= arithmeticExpression (op= relationalOperator e2= arithmeticExpression )? ;
	[GrammarRule("relationalExpression")]
	private Expression relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 3);
		TraceIn("relationalExpression", 3);
		Expression expression = default(Expression);


		Expression e1 = default(Expression);
		string op = default(string);
		Expression e2 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(57, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:58:3: (e1= arithmeticExpression (op= relationalOperator e2= arithmeticExpression )? )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:58:5: e1= arithmeticExpression (op= relationalOperator e2= arithmeticExpression )?
			{
			DebugLocation(58, 7);
			PushFollow(Follow._arithmeticExpression_in_relationalExpression153);
			e1=arithmeticExpression();
			PopFollow();
			if (state.failed) return expression;
			DebugLocation(59, 3);
			if (state.backtracking == 0)
			{

							expression = e1;
						
			}
			DebugLocation(62, 5);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:62:5: (op= relationalOperator e2= arithmeticExpression )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if (((LA2_1>=EQUAL && LA2_1<=GT)||LA2_1==LE||LA2_1==LT||LA2_1==NEQUAL))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:62:7: op= relationalOperator e2= arithmeticExpression
				{
				DebugLocation(62, 9);
				PushFollow(Follow._relationalOperator_in_relationalExpression167);
				op=relationalOperator();
				PopFollow();
				if (state.failed) return expression;
				DebugLocation(62, 31);
				PushFollow(Follow._arithmeticExpression_in_relationalExpression171);
				e2=arithmeticExpression();
				PopFollow();
				if (state.failed) return expression;
				DebugLocation(63, 3);
				if (state.backtracking == 0)
				{

								expression = new RelationalExpression(e1);
								((RelationalExpression)expression).Add(op, e2);
							
				}

				}
				break;

			}
			} finally { DebugExitSubRule(2); }


			}

		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("relationalExpression", 3);
			LeaveRule("relationalExpression", 3);
			LeaveRule_relationalExpression();
		}
		DebugLocation(68, 2);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return expression;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_arithmeticExpression();
	partial void LeaveRule_arithmeticExpression();
	// $ANTLR start "arithmeticExpression"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:70:1: arithmeticExpression returns [Expression expression] : e1= unaryExpression (op= arithmeticOperator e2= unaryExpression )* ;
	[GrammarRule("arithmeticExpression")]
	private Expression arithmeticExpression()
	{
		EnterRule_arithmeticExpression();
		EnterRule("arithmeticExpression", 4);
		TraceIn("arithmeticExpression", 4);
		Expression expression = default(Expression);


		Expression e1 = default(Expression);
		string op = default(string);
		Expression e2 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "arithmeticExpression");
		DebugLocation(70, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:71:3: (e1= unaryExpression (op= arithmeticOperator e2= unaryExpression )* )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:71:5: e1= unaryExpression (op= arithmeticOperator e2= unaryExpression )*
			{
			DebugLocation(71, 7);
			PushFollow(Follow._unaryExpression_in_arithmeticExpression198);
			e1=unaryExpression();
			PopFollow();
			if (state.failed) return expression;
			DebugLocation(72, 3);
			if (state.backtracking == 0)
			{

							expression = e1;
						
			}
			DebugLocation(75, 5);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:75:5: (op= arithmeticOperator e2= unaryExpression )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==DIVIDE||(LA3_1>=MINUS && LA3_1<=MULT)||LA3_1==PLUS))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:75:7: op= arithmeticOperator e2= unaryExpression
					{
					DebugLocation(75, 9);
					PushFollow(Follow._arithmeticOperator_in_arithmeticExpression212);
					op=arithmeticOperator();
					PopFollow();
					if (state.failed) return expression;
					DebugLocation(75, 31);
					PushFollow(Follow._unaryExpression_in_arithmeticExpression216);
					e2=unaryExpression();
					PopFollow();
					if (state.failed) return expression;
					DebugLocation(76, 3);
					if (state.backtracking == 0)
					{

									 expression = ((Select)expression).add(op, (Select)e2);
								
					}

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("arithmeticExpression", 4);
			LeaveRule("arithmeticExpression", 4);
			LeaveRule_arithmeticExpression();
		}
		DebugLocation(80, 2);
		} finally { DebugExitRule(GrammarFileName, "arithmeticExpression"); }
		return expression;

	}
	// $ANTLR end "arithmeticExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:82:1: unaryExpression returns [Expression expression] : ( (op= unaryOperator e1= postfixExpression ) |e1= postfixExpression );
	[GrammarRule("unaryExpression")]
	private Expression unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 5);
		TraceIn("unaryExpression", 5);
		Expression expression = default(Expression);


		string op = default(string);
		Expression e1 = default(Expression);

		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(82, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:83:3: ( (op= unaryOperator e1= postfixExpression ) |e1= postfixExpression )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==MINUS||LA4_1==38))
			{
				alt4 = 1;
			}
			else if ((LA4_1==NAME||LA4_1==NUMBER||LA4_1==STRING))
			{
				alt4 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return expression;}
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:83:5: (op= unaryOperator e1= postfixExpression )
				{
				DebugLocation(83, 5);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:83:5: (op= unaryOperator e1= postfixExpression )
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:83:7: op= unaryOperator e1= postfixExpression
				{
				DebugLocation(83, 9);
				PushFollow(Follow._unaryOperator_in_unaryExpression245);
				op=unaryOperator();
				PopFollow();
				if (state.failed) return expression;
				DebugLocation(83, 26);
				PushFollow(Follow._postfixExpression_in_unaryExpression249);
				e1=postfixExpression();
				PopFollow();
				if (state.failed) return expression;

				}

				DebugLocation(84, 3);
				if (state.backtracking == 0)
				{

								expression = ((Select)e1).selectList[0] = new UnaryExpression(op, ((Select)e1).selectList[0]);
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:87:5: e1= postfixExpression
				{
				DebugLocation(87, 7);
				PushFollow(Follow._postfixExpression_in_unaryExpression263);
				e1=postfixExpression();
				PopFollow();
				if (state.failed) return expression;
				DebugLocation(88, 3);
				if (state.backtracking == 0)
				{

								expression = e1;
							
				}

				}
				break;

			}
		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("unaryExpression", 5);
			LeaveRule("unaryExpression", 5);
			LeaveRule_unaryExpression();
		}
		DebugLocation(91, 2);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return expression;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();
	// $ANTLR start "postfixExpression"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:93:1: postfixExpression returns [Expression expression] : ( ( STRING | NUMBER )=>l= literal |n= NAME ( ( DOT )=> DOT n= NAME | ( RARROW NAME LPAREN NAME ( COMMA NAME )* BAR )=> RARROW f= NAME LPAREN bl= bindingList[context] BAR ap= actualParameterList RPAREN | RARROW f= NAME LPAREN ap= actualParameterList RPAREN )* );
	[GrammarRule("postfixExpression")]
	private Expression postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 6);
		TraceIn("postfixExpression", 6);
		Expression expression = default(Expression);


		CommonToken n = default(CommonToken);
		CommonToken f = default(CommonToken);
		Select l = default(Select);
		List<TableBinding> bl = default(List<TableBinding>);
		List<Expression> ap = default(List<Expression>);

		string context = null;
		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(93, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:94:3: ( ( STRING | NUMBER )=>l= literal |n= NAME ( ( DOT )=> DOT n= NAME | ( RARROW NAME LPAREN NAME ( COMMA NAME )* BAR )=> RARROW f= NAME LPAREN bl= bindingList[context] BAR ap= actualParameterList RPAREN | RARROW f= NAME LPAREN ap= actualParameterList RPAREN )* )
			int alt6=2;
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==STRING) && (EvaluatePredicate(synpred1_OCLConstraint_fragment)))
			{
				alt6 = 1;
			}
			else if ((LA6_1==NUMBER) && (EvaluatePredicate(synpred1_OCLConstraint_fragment)))
			{
				alt6 = 1;
			}
			else if ((LA6_1==NAME))
			{
				alt6 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return expression;}
				NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:94:5: ( STRING | NUMBER )=>l= literal
				{
				DebugLocation(94, 27);
				PushFollow(Follow._literal_in_postfixExpression300);
				l=literal();
				PopFollow();
				if (state.failed) return expression;
				DebugLocation(95, 3);
				if (state.backtracking == 0)
				{

								expression = l;
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:98:5: n= NAME ( ( DOT )=> DOT n= NAME | ( RARROW NAME LPAREN NAME ( COMMA NAME )* BAR )=> RARROW f= NAME LPAREN bl= bindingList[context] BAR ap= actualParameterList RPAREN | RARROW f= NAME LPAREN ap= actualParameterList RPAREN )*
				{
				DebugLocation(98, 6);
				n=(CommonToken)Match(input,NAME,Follow._NAME_in_postfixExpression312); if (state.failed) return expression;
				DebugLocation(99, 3);
				if (state.backtracking == 0)
				{

								TableBinding tableBinding = tryToGetBinding(n.Text);
								if (tableBinding == null)
								{
									context = n.Text;
								}
								else
								{
									context = tableBinding.tableName;
								}

								expression = new Select(context, tableBinding);
							
				}
				DebugLocation(112, 2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:112:2: ( ( DOT )=> DOT n= NAME | ( RARROW NAME LPAREN NAME ( COMMA NAME )* BAR )=> RARROW f= NAME LPAREN bl= bindingList[context] BAR ap= actualParameterList RPAREN | RARROW f= NAME LPAREN ap= actualParameterList RPAREN )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=4;
					try { DebugEnterDecision(5, false);
					try
					{
						alt5 = dfa5.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:112:4: ( DOT )=> DOT n= NAME
						{
						DebugLocation(112, 13);
						Match(input,DOT,Follow._DOT_in_postfixExpression327); if (state.failed) return expression;
						DebugLocation(112, 18);
						n=(CommonToken)Match(input,NAME,Follow._NAME_in_postfixExpression331); if (state.failed) return expression;
						DebugLocation(113, 4);
						if (state.backtracking == 0)
						{

											List<NavigationItem> navigationItems = ddlPackage.getNavigation(context, n.Text);

											if (navigationItems == null) //is a column
											{
												ColumnExpression columnExpression = new ColumnExpression(n.Text);
												((Select)expression).selectList.Add(columnExpression);
											}
											else //add data for join(s)
											{
												((Select)expression).from.AddRange(navigationItems);
												context = navigationItems[navigationItems.Count-1].targetTable;
											}
										
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:128:5: ( RARROW NAME LPAREN NAME ( COMMA NAME )* BAR )=> RARROW f= NAME LPAREN bl= bindingList[context] BAR ap= actualParameterList RPAREN
						{
						DebugLocation(129, 5);
						Match(input,RARROW,Follow._RARROW_in_postfixExpression369); if (state.failed) return expression;
						DebugLocation(129, 13);
						f=(CommonToken)Match(input,NAME,Follow._NAME_in_postfixExpression373); if (state.failed) return expression;
						DebugLocation(129, 19);
						Match(input,LPAREN,Follow._LPAREN_in_postfixExpression375); if (state.failed) return expression;
						DebugLocation(129, 28);
						PushFollow(Follow._bindingList_in_postfixExpression379);
						bl=bindingList(context);
						PopFollow();
						if (state.failed) return expression;
						DebugLocation(129, 50);
						Match(input,BAR,Follow._BAR_in_postfixExpression382); if (state.failed) return expression;
						DebugLocation(129, 56);
						PushFollow(Follow._actualParameterList_in_postfixExpression386);
						ap=actualParameterList();
						PopFollow();
						if (state.failed) return expression;
						DebugLocation(129, 77);
						Match(input,RPAREN,Follow._RPAREN_in_postfixExpression388); if (state.failed) return expression;
						DebugLocation(130, 4);
						if (state.backtracking == 0)
						{

											expression = advancedFunctionCall((Select)expression, f.Text, bl, ap);
											unregisterBindings(bl);
										
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:134:5: RARROW f= NAME LPAREN ap= actualParameterList RPAREN
						{
						DebugLocation(134, 5);
						Match(input,RARROW,Follow._RARROW_in_postfixExpression399); if (state.failed) return expression;
						DebugLocation(134, 13);
						f=(CommonToken)Match(input,NAME,Follow._NAME_in_postfixExpression403); if (state.failed) return expression;
						DebugLocation(134, 19);
						Match(input,LPAREN,Follow._LPAREN_in_postfixExpression405); if (state.failed) return expression;
						DebugLocation(134, 28);
						PushFollow(Follow._actualParameterList_in_postfixExpression409);
						ap=actualParameterList();
						PopFollow();
						if (state.failed) return expression;
						DebugLocation(134, 49);
						Match(input,RPAREN,Follow._RPAREN_in_postfixExpression411); if (state.failed) return expression;
						DebugLocation(135, 4);
						if (state.backtracking == 0)
						{

											expression = simpleFunctionCall((Select)expression, f.Text, ap);
										
						}

						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }


				}
				break;

			}
		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("postfixExpression", 6);
			LeaveRule("postfixExpression", 6);
			LeaveRule_postfixExpression();
		}
		DebugLocation(139, 2);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return expression;

	}
	// $ANTLR end "postfixExpression"

	partial void EnterRule_bindingList();
	partial void LeaveRule_bindingList();
	// $ANTLR start "bindingList"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:141:1: bindingList[string tableName] returns [List<TableBinding> tableBindings] : n= NAME ( COMMA n= NAME )* ;
	[GrammarRule("bindingList")]
	private List<TableBinding> bindingList(string tableName)
	{
		EnterRule_bindingList();
		EnterRule("bindingList", 7);
		TraceIn("bindingList", 7);
		List<TableBinding> tableBindings = default(List<TableBinding>);


		CommonToken n = default(CommonToken);

		try { DebugEnterRule(GrammarFileName, "bindingList");
		DebugLocation(141, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:142:3: (n= NAME ( COMMA n= NAME )* )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:142:5: n= NAME ( COMMA n= NAME )*
			{
			DebugLocation(142, 6);
			n=(CommonToken)Match(input,NAME,Follow._NAME_in_bindingList440); if (state.failed) return tableBindings;
			DebugLocation(143, 3);
			if (state.backtracking == 0)
			{

							tableBindings = new List<TableBinding>();
							tableBindings.Add(registerBinding(n.Text, tableName));
						
			}
			DebugLocation(148, 2);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:148:2: ( COMMA n= NAME )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==COMMA))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:148:3: COMMA n= NAME
					{
					DebugLocation(148, 3);
					Match(input,COMMA,Follow._COMMA_in_bindingList453); if (state.failed) return tableBindings;
					DebugLocation(148, 10);
					n=(CommonToken)Match(input,NAME,Follow._NAME_in_bindingList457); if (state.failed) return tableBindings;
					DebugLocation(149, 3);
					if (state.backtracking == 0)
					{

									tableBindings.Add(registerBinding(n.Text, tableName));
								
					}

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("bindingList", 7);
			LeaveRule("bindingList", 7);
			LeaveRule_bindingList();
		}
		DebugLocation(153, 2);
		} finally { DebugExitRule(GrammarFileName, "bindingList"); }
		return tableBindings;

	}
	// $ANTLR end "bindingList"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:155:1: literal returns [Select select] : ( STRING | NUMBER );
	[GrammarRule("literal")]
	private Select literal()
	{
		EnterRule_literal();
		EnterRule("literal", 8);
		TraceIn("literal", 8);
		Select select = default(Select);


		CommonToken STRING1 = default(CommonToken);
		CommonToken NUMBER2 = default(CommonToken);

		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(155, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:156:3: ( STRING | NUMBER )
			int alt8=2;
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==STRING))
			{
				alt8 = 1;
			}
			else if ((LA8_1==NUMBER))
			{
				alt8 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return select;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:156:5: STRING
				{
				DebugLocation(156, 5);
				STRING1=(CommonToken)Match(input,STRING,Follow._STRING_in_literal482); if (state.failed) return select;
				DebugLocation(156, 12);
				if (state.backtracking == 0)
				{
					select = new Select(new StringExpression(STRING1.Text));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:157:5: NUMBER
				{
				DebugLocation(157, 5);
				NUMBER2=(CommonToken)Match(input,NUMBER,Follow._NUMBER_in_literal490); if (state.failed) return select;
				DebugLocation(157, 12);
				if (state.backtracking == 0)
				{
					select = new Select(new NumberExpression(NUMBER2.Text));
				}

				}
				break;

			}
		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("literal", 8);
			LeaveRule("literal", 8);
			LeaveRule_literal();
		}
		DebugLocation(158, 2);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return select;

	}
	// $ANTLR end "literal"

	partial void EnterRule_actualParameterList();
	partial void LeaveRule_actualParameterList();
	// $ANTLR start "actualParameterList"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:160:1: actualParameterList returns [List<Expression> parameters] : (le= logicalExpression ( COMMA le2= logicalExpression )* )? ;
	[GrammarRule("actualParameterList")]
	private List<Expression> actualParameterList()
	{
		EnterRule_actualParameterList();
		EnterRule("actualParameterList", 9);
		TraceIn("actualParameterList", 9);
		List<Expression> parameters = default(List<Expression>);


		Expression le = default(Expression);
		Expression le2 = default(Expression);

		parameters = new List<Expression>();
		try { DebugEnterRule(GrammarFileName, "actualParameterList");
		DebugLocation(160, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:161:3: ( (le= logicalExpression ( COMMA le2= logicalExpression )* )? )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:161:5: (le= logicalExpression ( COMMA le2= logicalExpression )* )?
			{
			DebugLocation(161, 5);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:161:5: (le= logicalExpression ( COMMA le2= logicalExpression )* )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==MINUS||LA10_1==NAME||LA10_1==NUMBER||LA10_1==STRING||LA10_1==38))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:161:6: le= logicalExpression ( COMMA le2= logicalExpression )*
				{
				DebugLocation(161, 8);
				PushFollow(Follow._logicalExpression_in_actualParameterList516);
				le=logicalExpression();
				PopFollow();
				if (state.failed) return parameters;
				DebugLocation(162, 3);
				if (state.backtracking == 0)
				{

								parameters.Add(le);
							
				}
				DebugLocation(165, 3);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:165:3: ( COMMA le2= logicalExpression )*
				try { DebugEnterSubRule(9);
				while (true)
				{
					int alt9=2;
					try { DebugEnterDecision(9, false);
					int LA9_1 = input.LA(1);

					if ((LA9_1==COMMA))
					{
						alt9 = 1;
					}


					} finally { DebugExitDecision(9); }
					switch ( alt9 )
					{
					case 1:
						DebugEnterAlt(1);
						// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:165:4: COMMA le2= logicalExpression
						{
						DebugLocation(165, 4);
						Match(input,COMMA,Follow._COMMA_in_actualParameterList525); if (state.failed) return parameters;
						DebugLocation(165, 13);
						PushFollow(Follow._logicalExpression_in_actualParameterList529);
						le2=logicalExpression();
						PopFollow();
						if (state.failed) return parameters;
						DebugLocation(166, 4);
						if (state.backtracking == 0)
						{

											parameters.Add(le2);
										
						}

						}
						break;

					default:
						goto loop9;
					}
				}

				loop9:
					;

				} finally { DebugExitSubRule(9); }


				}
				break;

			}
			} finally { DebugExitSubRule(10); }


			}

		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("actualParameterList", 9);
			LeaveRule("actualParameterList", 9);
			LeaveRule_actualParameterList();
		}
		DebugLocation(171, 2);
		} finally { DebugExitRule(GrammarFileName, "actualParameterList"); }
		return parameters;

	}
	// $ANTLR end "actualParameterList"

	partial void EnterRule_arithmeticOperator();
	partial void LeaveRule_arithmeticOperator();
	// $ANTLR start "arithmeticOperator"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:173:1: arithmeticOperator returns [string op] : (ao= addOperator |mo= multiplyOperator );
	[GrammarRule("arithmeticOperator")]
	private string arithmeticOperator()
	{
		EnterRule_arithmeticOperator();
		EnterRule("arithmeticOperator", 10);
		TraceIn("arithmeticOperator", 10);
		string op = default(string);


		string ao = default(string);
		string mo = default(string);

		try { DebugEnterRule(GrammarFileName, "arithmeticOperator");
		DebugLocation(173, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:174:3: (ao= addOperator |mo= multiplyOperator )
			int alt11=2;
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==MINUS||LA11_1==PLUS))
			{
				alt11 = 1;
			}
			else if ((LA11_1==DIVIDE||LA11_1==MULT))
			{
				alt11 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return op;}
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:174:5: ao= addOperator
				{
				DebugLocation(174, 7);
				PushFollow(Follow._addOperator_in_arithmeticOperator562);
				ao=addOperator();
				PopFollow();
				if (state.failed) return op;
				DebugLocation(174, 21);
				if (state.backtracking == 0)
				{
					op = ao;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:175:5: mo= multiplyOperator
				{
				DebugLocation(175, 7);
				PushFollow(Follow._multiplyOperator_in_arithmeticOperator573);
				mo=multiplyOperator();
				PopFollow();
				if (state.failed) return op;
				DebugLocation(175, 25);
				if (state.backtracking == 0)
				{
					op = mo;
				}

				}
				break;

			}
		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("arithmeticOperator", 10);
			LeaveRule("arithmeticOperator", 10);
			LeaveRule_arithmeticOperator();
		}
		DebugLocation(176, 2);
		} finally { DebugExitRule(GrammarFileName, "arithmeticOperator"); }
		return op;

	}
	// $ANTLR end "arithmeticOperator"

	partial void EnterRule_logicalOperator();
	partial void LeaveRule_logicalOperator();
	// $ANTLR start "logicalOperator"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:178:1: logicalOperator returns [string op] : ( 'and' | 'or' | 'implies' );
	[GrammarRule("logicalOperator")]
	private string logicalOperator()
	{
		EnterRule_logicalOperator();
		EnterRule("logicalOperator", 11);
		TraceIn("logicalOperator", 11);
		string op = default(string);


		try { DebugEnterRule(GrammarFileName, "logicalOperator");
		DebugLocation(178, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:179:3: ( 'and' | 'or' | 'implies' )
			int alt12=3;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case 35:
				{
				alt12 = 1;
				}
				break;
			case 39:
				{
				alt12 = 2;
				}
				break;
			case 36:
				{
				alt12 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return op;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:179:5: 'and'
				{
				DebugLocation(179, 5);
				Match(input,35,Follow._35_in_logicalOperator592); if (state.failed) return op;
				DebugLocation(179, 11);
				if (state.backtracking == 0)
				{
					op = "AND";
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:180:5: 'or'
				{
				DebugLocation(180, 5);
				Match(input,39,Follow._39_in_logicalOperator600); if (state.failed) return op;
				DebugLocation(180, 10);
				if (state.backtracking == 0)
				{
					op = "OR";
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:181:5: 'implies'
				{
				DebugLocation(181, 5);
				Match(input,36,Follow._36_in_logicalOperator608); if (state.failed) return op;
				DebugLocation(181, 15);
				if (state.backtracking == 0)
				{
					op = "IMPLIES";
				}

				}
				break;

			}
		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("logicalOperator", 11);
			LeaveRule("logicalOperator", 11);
			LeaveRule_logicalOperator();
		}
		DebugLocation(183, 2);
		} finally { DebugExitRule(GrammarFileName, "logicalOperator"); }
		return op;

	}
	// $ANTLR end "logicalOperator"

	partial void EnterRule_relationalOperator();
	partial void LeaveRule_relationalOperator();
	// $ANTLR start "relationalOperator"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:185:1: relationalOperator returns [string op] : ( EQUAL | GT | LT | GE | LE | NEQUAL );
	[GrammarRule("relationalOperator")]
	private string relationalOperator()
	{
		EnterRule_relationalOperator();
		EnterRule("relationalOperator", 12);
		TraceIn("relationalOperator", 12);
		string op = default(string);


		CommonToken EQUAL3 = default(CommonToken);
		CommonToken GT4 = default(CommonToken);
		CommonToken LT5 = default(CommonToken);
		CommonToken GE6 = default(CommonToken);
		CommonToken LE7 = default(CommonToken);
		CommonToken NEQUAL8 = default(CommonToken);

		try { DebugEnterRule(GrammarFileName, "relationalOperator");
		DebugLocation(185, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:186:3: ( EQUAL | GT | LT | GE | LE | NEQUAL )
			int alt13=6;
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case EQUAL:
				{
				alt13 = 1;
				}
				break;
			case GT:
				{
				alt13 = 2;
				}
				break;
			case LT:
				{
				alt13 = 3;
				}
				break;
			case GE:
				{
				alt13 = 4;
				}
				break;
			case LE:
				{
				alt13 = 5;
				}
				break;
			case NEQUAL:
				{
				alt13 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return op;}
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:186:5: EQUAL
				{
				DebugLocation(186, 5);
				EQUAL3=(CommonToken)Match(input,EQUAL,Follow._EQUAL_in_relationalOperator630); if (state.failed) return op;
				DebugLocation(186, 11);
				if (state.backtracking == 0)
				{
					op = EQUAL3.Text;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:187:5: GT
				{
				DebugLocation(187, 5);
				GT4=(CommonToken)Match(input,GT,Follow._GT_in_relationalOperator638); if (state.failed) return op;
				DebugLocation(187, 9);
				if (state.backtracking == 0)
				{
					op = GT4.Text;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:188:5: LT
				{
				DebugLocation(188, 5);
				LT5=(CommonToken)Match(input,LT,Follow._LT_in_relationalOperator647); if (state.failed) return op;
				DebugLocation(188, 9);
				if (state.backtracking == 0)
				{
					op = LT5.Text;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:189:5: GE
				{
				DebugLocation(189, 5);
				GE6=(CommonToken)Match(input,GE,Follow._GE_in_relationalOperator656); if (state.failed) return op;
				DebugLocation(189, 9);
				if (state.backtracking == 0)
				{
					op = GE6.Text;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:190:5: LE
				{
				DebugLocation(190, 5);
				LE7=(CommonToken)Match(input,LE,Follow._LE_in_relationalOperator665); if (state.failed) return op;
				DebugLocation(190, 9);
				if (state.backtracking == 0)
				{
					op = LE7.Text;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:191:5: NEQUAL
				{
				DebugLocation(191, 5);
				NEQUAL8=(CommonToken)Match(input,NEQUAL,Follow._NEQUAL_in_relationalOperator674); if (state.failed) return op;
				DebugLocation(191, 12);
				if (state.backtracking == 0)
				{
					op = NEQUAL8.Text;
				}

				}
				break;

			}
		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("relationalOperator", 12);
			LeaveRule("relationalOperator", 12);
			LeaveRule_relationalOperator();
		}
		DebugLocation(192, 2);
		} finally { DebugExitRule(GrammarFileName, "relationalOperator"); }
		return op;

	}
	// $ANTLR end "relationalOperator"

	partial void EnterRule_addOperator();
	partial void LeaveRule_addOperator();
	// $ANTLR start "addOperator"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:194:1: addOperator returns [string op] : ( PLUS | MINUS );
	[GrammarRule("addOperator")]
	private string addOperator()
	{
		EnterRule_addOperator();
		EnterRule("addOperator", 13);
		TraceIn("addOperator", 13);
		string op = default(string);


		CommonToken PLUS9 = default(CommonToken);
		CommonToken MINUS10 = default(CommonToken);

		try { DebugEnterRule(GrammarFileName, "addOperator");
		DebugLocation(194, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:195:3: ( PLUS | MINUS )
			int alt14=2;
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==PLUS))
			{
				alt14 = 1;
			}
			else if ((LA14_1==MINUS))
			{
				alt14 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return op;}
				NoViableAltException nvae = new NoViableAltException("", 14, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:195:5: PLUS
				{
				DebugLocation(195, 5);
				PLUS9=(CommonToken)Match(input,PLUS,Follow._PLUS_in_addOperator693); if (state.failed) return op;
				DebugLocation(195, 10);
				if (state.backtracking == 0)
				{
					op = PLUS9.Text;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:196:5: MINUS
				{
				DebugLocation(196, 5);
				MINUS10=(CommonToken)Match(input,MINUS,Follow._MINUS_in_addOperator701); if (state.failed) return op;
				DebugLocation(196, 11);
				if (state.backtracking == 0)
				{
					op = MINUS10.Text;
				}

				}
				break;

			}
		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("addOperator", 13);
			LeaveRule("addOperator", 13);
			LeaveRule_addOperator();
		}
		DebugLocation(197, 2);
		} finally { DebugExitRule(GrammarFileName, "addOperator"); }
		return op;

	}
	// $ANTLR end "addOperator"

	partial void EnterRule_multiplyOperator();
	partial void LeaveRule_multiplyOperator();
	// $ANTLR start "multiplyOperator"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:199:1: multiplyOperator returns [string op] : ( MULT | DIVIDE );
	[GrammarRule("multiplyOperator")]
	private string multiplyOperator()
	{
		EnterRule_multiplyOperator();
		EnterRule("multiplyOperator", 14);
		TraceIn("multiplyOperator", 14);
		string op = default(string);


		CommonToken MULT11 = default(CommonToken);
		CommonToken DIVIDE12 = default(CommonToken);

		try { DebugEnterRule(GrammarFileName, "multiplyOperator");
		DebugLocation(199, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:200:3: ( MULT | DIVIDE )
			int alt15=2;
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==MULT))
			{
				alt15 = 1;
			}
			else if ((LA15_1==DIVIDE))
			{
				alt15 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return op;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:200:5: MULT
				{
				DebugLocation(200, 5);
				MULT11=(CommonToken)Match(input,MULT,Follow._MULT_in_multiplyOperator720); if (state.failed) return op;
				DebugLocation(200, 10);
				if (state.backtracking == 0)
				{
					op = MULT11.Text;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:201:5: DIVIDE
				{
				DebugLocation(201, 5);
				DIVIDE12=(CommonToken)Match(input,DIVIDE,Follow._DIVIDE_in_multiplyOperator728); if (state.failed) return op;
				DebugLocation(201, 12);
				if (state.backtracking == 0)
				{
					op = DIVIDE12.Text;
				}

				}
				break;

			}
		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("multiplyOperator", 14);
			LeaveRule("multiplyOperator", 14);
			LeaveRule_multiplyOperator();
		}
		DebugLocation(202, 2);
		} finally { DebugExitRule(GrammarFileName, "multiplyOperator"); }
		return op;

	}
	// $ANTLR end "multiplyOperator"

	partial void EnterRule_unaryOperator();
	partial void LeaveRule_unaryOperator();
	// $ANTLR start "unaryOperator"
	// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:204:1: unaryOperator returns [string op] : ( MINUS | 'not' );
	[GrammarRule("unaryOperator")]
	private string unaryOperator()
	{
		EnterRule_unaryOperator();
		EnterRule("unaryOperator", 15);
		TraceIn("unaryOperator", 15);
		string op = default(string);


		CommonToken MINUS13 = default(CommonToken);

		try { DebugEnterRule(GrammarFileName, "unaryOperator");
		DebugLocation(204, 2);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:205:3: ( MINUS | 'not' )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==MINUS))
			{
				alt16 = 1;
			}
			else if ((LA16_1==38))
			{
				alt16 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return op;}
				NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:205:5: MINUS
				{
				DebugLocation(205, 5);
				MINUS13=(CommonToken)Match(input,MINUS,Follow._MINUS_in_unaryOperator747); if (state.failed) return op;
				DebugLocation(205, 11);
				if (state.backtracking == 0)
				{
					op = MINUS13.Text;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:206:5: 'not'
				{
				DebugLocation(206, 5);
				Match(input,38,Follow._38_in_unaryOperator755); if (state.failed) return op;
				DebugLocation(206, 11);
				if (state.backtracking == 0)
				{
					op = "NOT";
				}

				}
				break;

			}
		}
		 
			catch (RecognitionException e) 
			{ 
				throw e; 
			}

		finally
		{
			TraceOut("unaryOperator", 15);
			LeaveRule("unaryOperator", 15);
			LeaveRule_unaryOperator();
		}
		DebugLocation(207, 2);
		} finally { DebugExitRule(GrammarFileName, "unaryOperator"); }
		return op;

	}
	// $ANTLR end "unaryOperator"

	partial void EnterRule_synpred1_OCLConstraint_fragment();
	partial void LeaveRule_synpred1_OCLConstraint_fragment();

	// $ANTLR start synpred1_OCLConstraint
	private void synpred1_OCLConstraint_fragment()
	{
		EnterRule_synpred1_OCLConstraint_fragment();
		EnterRule("synpred1_OCLConstraint_fragment", 16);
		TraceIn("synpred1_OCLConstraint_fragment", 16);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:94:5: ( STRING | NUMBER )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:
			{
			DebugLocation(94, 5);
			if (input.LA(1)==NUMBER||input.LA(1)==STRING)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred1_OCLConstraint_fragment", 16);
			LeaveRule("synpred1_OCLConstraint_fragment", 16);
			LeaveRule_synpred1_OCLConstraint_fragment();
		}
	}
	// $ANTLR end synpred1_OCLConstraint

	partial void EnterRule_synpred2_OCLConstraint_fragment();
	partial void LeaveRule_synpred2_OCLConstraint_fragment();

	// $ANTLR start synpred2_OCLConstraint
	private void synpred2_OCLConstraint_fragment()
	{
		EnterRule_synpred2_OCLConstraint_fragment();
		EnterRule("synpred2_OCLConstraint_fragment", 17);
		TraceIn("synpred2_OCLConstraint_fragment", 17);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:112:4: ( DOT )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:112:5: DOT
			{
			DebugLocation(112, 5);
			Match(input,DOT,Follow._DOT_in_synpred2_OCLConstraint322); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_OCLConstraint_fragment", 17);
			LeaveRule("synpred2_OCLConstraint_fragment", 17);
			LeaveRule_synpred2_OCLConstraint_fragment();
		}
	}
	// $ANTLR end synpred2_OCLConstraint

	partial void EnterRule_synpred3_OCLConstraint_fragment();
	partial void LeaveRule_synpred3_OCLConstraint_fragment();

	// $ANTLR start synpred3_OCLConstraint
	private void synpred3_OCLConstraint_fragment()
	{
		EnterRule_synpred3_OCLConstraint_fragment();
		EnterRule("synpred3_OCLConstraint_fragment", 18);
		TraceIn("synpred3_OCLConstraint_fragment", 18);
		try
		{
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:128:5: ( RARROW NAME LPAREN NAME ( COMMA NAME )* BAR )
			DebugEnterAlt(1);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:128:7: RARROW NAME LPAREN NAME ( COMMA NAME )* BAR
			{
			DebugLocation(128, 7);
			Match(input,RARROW,Follow._RARROW_in_synpred3_OCLConstraint345); if (state.failed) return;
			DebugLocation(128, 14);
			Match(input,NAME,Follow._NAME_in_synpred3_OCLConstraint347); if (state.failed) return;
			DebugLocation(128, 19);
			Match(input,LPAREN,Follow._LPAREN_in_synpred3_OCLConstraint349); if (state.failed) return;
			DebugLocation(128, 26);
			Match(input,NAME,Follow._NAME_in_synpred3_OCLConstraint351); if (state.failed) return;
			DebugLocation(128, 31);
			// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:128:31: ( COMMA NAME )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==COMMA))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// Z:\\EA_Addin_Model_Validator\\OCLtoSQLTranslator\\OCLConstraint.g:128:32: COMMA NAME
					{
					DebugLocation(128, 32);
					Match(input,COMMA,Follow._COMMA_in_synpred3_OCLConstraint354); if (state.failed) return;
					DebugLocation(128, 38);
					Match(input,NAME,Follow._NAME_in_synpred3_OCLConstraint356); if (state.failed) return;

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(128, 45);
			Match(input,BAR,Follow._BAR_in_synpred3_OCLConstraint360); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_OCLConstraint_fragment", 18);
			LeaveRule("synpred3_OCLConstraint_fragment", 18);
			LeaveRule_synpred3_OCLConstraint_fragment();
		}
	}
	// $ANTLR end synpred3_OCLConstraint
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA5 dfa5;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa5 = new DFA5( this, SpecialStateTransition5 );
	}

	private class DFA5 : DFA
	{
		private const string DFA5_eotS =
			"\xB\xFFFF";
		private const string DFA5_eofS =
			"\x1\x1\xA\xFFFF";
		private const string DFA5_minS =
			"\x1\x7\x2\xFFFF\x1\x16\x1\x12\x1\x14\x1\x5\x1\xFFFF\x1\x14\x1\xFFFF\x1"+
			"\x5";
		private const string DFA5_maxS =
			"\x1\x27\x2\xFFFF\x1\x16\x1\x12\x1\x26\x1\x27\x1\xFFFF\x1\x26\x1\xFFFF"+
			"\x1\x27";
		private const string DFA5_acceptS =
			"\x1\xFFFF\x1\x4\x1\x1\x4\xFFFF\x1\x3\x1\xFFFF\x1\x2\x1\xFFFF";
		private const string DFA5_specialS =
			"\x1\x0\x5\xFFFF\x1\x2\x3\xFFFF\x1\x1}>";
		private static readonly string[] DFA5_transitionS =
			{
				"\x1\x1\x1\xFFFF\x1\x1\x1\x2\x1\xFFFF\x3\x1\x2\xFFFF\x1\x1\x1\xFFFF\x3"+
				"\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x1\x1\xFFFF\x1\x3\x2\xFFFF\x1\x1\x4\xFFFF"+
				"\x2\x1\x2\xFFFF\x1\x1",
				"",
				"",
				"\x1\x4",
				"\x1\x5",
				"\x1\x7\x1\xFFFF\x1\x6\x1\xFFFF\x1\x7\x5\xFFFF\x1\x7\x2\xFFFF\x1\x7"+
				"\x4\xFFFF\x1\x7",
				"\x1\x9\x1\xFFFF\x1\x8\x1\xFFFF\x2\x7\x1\xFFFF\x3\x7\x2\xFFFF\x1\x7"+
				"\x1\xFFFF\x3\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\x7\x2\xFFFF"+
				"\x1\x7\x4\xFFFF\x2\x7\x2\xFFFF\x1\x7",
				"",
				"\x1\x7\x1\xFFFF\x1\xA\x1\xFFFF\x1\x7\x8\xFFFF\x1\x7\x4\xFFFF\x1\x7",
				"",
				"\x1\x9\x1\xFFFF\x1\x8\x1\xFFFF\x2\x7\x1\xFFFF\x3\x7\x2\xFFFF\x1\x7"+
				"\x1\xFFFF\x3\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\x7\x1\xFFFF\x1\x7\x2\xFFFF"+
				"\x1\x7\x4\xFFFF\x2\x7\x2\xFFFF\x1\x7"
			};

		private static readonly short[] DFA5_eot = DFA.UnpackEncodedString(DFA5_eotS);
		private static readonly short[] DFA5_eof = DFA.UnpackEncodedString(DFA5_eofS);
		private static readonly char[] DFA5_min = DFA.UnpackEncodedStringToUnsignedChars(DFA5_minS);
		private static readonly char[] DFA5_max = DFA.UnpackEncodedStringToUnsignedChars(DFA5_maxS);
		private static readonly short[] DFA5_accept = DFA.UnpackEncodedString(DFA5_acceptS);
		private static readonly short[] DFA5_special = DFA.UnpackEncodedString(DFA5_specialS);
		private static readonly short[][] DFA5_transition;

		static DFA5()
		{
			int numStates = DFA5_transitionS.Length;
			DFA5_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA5_transition[i] = DFA.UnpackEncodedString(DFA5_transitionS[i]);
			}
		}

		public DFA5( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 5;
			this.eot = DFA5_eot;
			this.eof = DFA5_eof;
			this.min = DFA5_min;
			this.max = DFA5_max;
			this.accept = DFA5_accept;
			this.special = DFA5_special;
			this.transition = DFA5_transition;
		}

		public override string Description { get { return "()* loopback of 112:2: ( ( DOT )=> DOT n= NAME | ( RARROW NAME LPAREN NAME ( COMMA NAME )* BAR )=> RARROW f= NAME LPAREN bl= bindingList[context] BAR ap= actualParameterList RPAREN | RARROW f= NAME LPAREN ap= actualParameterList RPAREN )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition5(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		s = -1;
		int LA5_1 = input.LA(1);
		int index5_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA5_1==EOF||LA5_1==COMMA||LA5_1==DIVIDE||(LA5_1>=EQUAL && LA5_1<=GT)||LA5_1==LE||(LA5_1>=LT && LA5_1<=MULT)||LA5_1==NEQUAL||LA5_1==PLUS||LA5_1==RPAREN||(LA5_1>=35 && LA5_1<=36)||LA5_1==39)) {s = 1;}

				else if ((LA5_1==DOT) && (EvaluatePredicate(synpred2_OCLConstraint_fragment))) {s = 2;}

				else if ((LA5_1==RARROW)) {s = 3;}

				input.Seek(index5_1);
				break;
			}
		case 1:
			{
				input.Rewind();
				if ((LA5_1==BAR) && (EvaluatePredicate(synpred3_OCLConstraint_fragment))) {s = 9;}

				else if ((LA5_1==COMMA)) {s = 8;}

				else if (((LA5_1>=DIVIDE && LA5_1<=DOT)||(LA5_1>=EQUAL && LA5_1<=GT)||LA5_1==LE||(LA5_1>=LT && LA5_1<=MULT)||LA5_1==NEQUAL||LA5_1==PLUS||LA5_1==RARROW||LA5_1==RPAREN||(LA5_1>=35 && LA5_1<=36)||LA5_1==39)) {s = 7;}

				input.Seek(index5_1);
				break;
			}
		case 2:
			{
				input.Rewind();
				if ((LA5_1==COMMA)) {s = 8;}

				else if ((LA5_1==BAR) && (EvaluatePredicate(synpred3_OCLConstraint_fragment))) {s = 9;}

				else if (((LA5_1>=DIVIDE && LA5_1<=DOT)||(LA5_1>=EQUAL && LA5_1<=GT)||LA5_1==LE||(LA5_1>=LT && LA5_1<=MULT)||LA5_1==NEQUAL||LA5_1==PLUS||LA5_1==RARROW||LA5_1==RPAREN||(LA5_1>=35 && LA5_1<=36)||LA5_1==39)) {s = 7;}

				input.Seek(index5_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 5, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _37_in_constraint79 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _COLON_in_constraint81 = new BitSet(new ulong[]{0x4201500000UL});
		public static readonly BitSet _logicalExpression_in_constraint85 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_constraint87 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpression_in_logicalExpression108 = new BitSet(new ulong[]{0x9800000002UL});
		public static readonly BitSet _logicalOperator_in_logicalExpression122 = new BitSet(new ulong[]{0x4201500000UL});
		public static readonly BitSet _relationalExpression_in_logicalExpression126 = new BitSet(new ulong[]{0x9800000002UL});
		public static readonly BitSet _arithmeticExpression_in_relationalExpression153 = new BitSet(new ulong[]{0x8A7002UL});
		public static readonly BitSet _relationalOperator_in_relationalExpression167 = new BitSet(new ulong[]{0x4201500000UL});
		public static readonly BitSet _arithmeticExpression_in_relationalExpression171 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpression_in_arithmeticExpression198 = new BitSet(new ulong[]{0x2300202UL});
		public static readonly BitSet _arithmeticOperator_in_arithmeticExpression212 = new BitSet(new ulong[]{0x4201500000UL});
		public static readonly BitSet _unaryExpression_in_arithmeticExpression216 = new BitSet(new ulong[]{0x2300202UL});
		public static readonly BitSet _unaryOperator_in_unaryExpression245 = new BitSet(new ulong[]{0x201400000UL});
		public static readonly BitSet _postfixExpression_in_unaryExpression249 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_unaryExpression263 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_in_postfixExpression300 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NAME_in_postfixExpression312 = new BitSet(new ulong[]{0x8000402UL});
		public static readonly BitSet _DOT_in_postfixExpression327 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _NAME_in_postfixExpression331 = new BitSet(new ulong[]{0x8000402UL});
		public static readonly BitSet _RARROW_in_postfixExpression369 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _NAME_in_postfixExpression373 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _LPAREN_in_postfixExpression375 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _bindingList_in_postfixExpression379 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _BAR_in_postfixExpression382 = new BitSet(new ulong[]{0x4241500000UL});
		public static readonly BitSet _actualParameterList_in_postfixExpression386 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _RPAREN_in_postfixExpression388 = new BitSet(new ulong[]{0x8000402UL});
		public static readonly BitSet _RARROW_in_postfixExpression399 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _NAME_in_postfixExpression403 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _LPAREN_in_postfixExpression405 = new BitSet(new ulong[]{0x4241500000UL});
		public static readonly BitSet _actualParameterList_in_postfixExpression409 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _RPAREN_in_postfixExpression411 = new BitSet(new ulong[]{0x8000402UL});
		public static readonly BitSet _NAME_in_bindingList440 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _COMMA_in_bindingList453 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _NAME_in_bindingList457 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _STRING_in_literal482 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_literal490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalExpression_in_actualParameterList516 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _COMMA_in_actualParameterList525 = new BitSet(new ulong[]{0x4201500000UL});
		public static readonly BitSet _logicalExpression_in_actualParameterList529 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _addOperator_in_arithmeticOperator562 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multiplyOperator_in_arithmeticOperator573 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _35_in_logicalOperator592 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _39_in_logicalOperator600 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _36_in_logicalOperator608 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQUAL_in_relationalOperator630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GT_in_relationalOperator638 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_relationalOperator647 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GE_in_relationalOperator656 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LE_in_relationalOperator665 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEQUAL_in_relationalOperator674 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_addOperator693 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_addOperator701 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MULT_in_multiplyOperator720 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIVIDE_in_multiplyOperator728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_unaryOperator747 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _38_in_unaryOperator755 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_synpred2_OCLConstraint322 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RARROW_in_synpred3_OCLConstraint345 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _NAME_in_synpred3_OCLConstraint347 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _LPAREN_in_synpred3_OCLConstraint349 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _NAME_in_synpred3_OCLConstraint351 = new BitSet(new ulong[]{0xA0UL});
		public static readonly BitSet _COMMA_in_synpred3_OCLConstraint354 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _NAME_in_synpred3_OCLConstraint356 = new BitSet(new ulong[]{0xA0UL});
		public static readonly BitSet _BAR_in_synpred3_OCLConstraint360 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace OCLtoSQL
